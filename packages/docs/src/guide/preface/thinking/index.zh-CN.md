---
title: 思考
group:
  title: 前言
  order: 2
---

# 苦不堪言的 mapStateToProps

在过去我们的工作中，虽然 dura 提供了大量的类型推导，但是依然逃脱不掉大量的 **样板代码**，让我们看一下下面的例子：

<code src="../../../example/mapStateToProps.tsx" inline />

当然，我们能够理解规避无意义渲染的重要性，我们也了解 [react-redux](https://react-redux.js.org/) 内部使用的 [shallowEqual](https://github.com/reduxjs/react-redux/blob/58ae5edee510a2f2f3bc577f55057fe9142f2976/src/utils/shallowEqual.js)。但是针对如此的样板代码依然让我们长期的工作中备受折磨。我们试图去解决这个问题。

幸运的是，ES6 为我们提供了 [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) ，让我们得以劫持对象的 **get** 访问器，如此我们将全局完整的 state 信息进行代理之后直接传递给组件，并劫持记录组件对代理对象的所有访问路径。当全局的 state 每一次发生变更之后，我们借助 [immer](https://immerjs.github.io/immer/docs/introduction) 获取到修改的属性路径与在这之前每一个组件收集到的访问路径进行对比，如发现有交集部分，则决定渲染该组件。

# Store 的单根性

实际上，在最早的时候，我们使用的并不是 redux ， 而是遵循 [**flux 架构**](https://github.com/facebook/flux) 自研了一套状态机，这套状态机在最早我们使用的时候是基于页面级别的，当多个页面需要共享状态的变更的时候，通常我们会采取**消息总线**的方式来进行同步调度，

一开始，这并没有什么问题。但是伴随着业务的复杂度越来越高，通常纯前端完成一个完善的业务可能需要跨越十几个页面，这样的话，我们需要在十几个不同的页面之间来回通过 **消息总线** 来同步最新的状态信息。
并且在这个业务场景中，可能还存在其他的业务模块携带一部分状态信息直接跳转到我们当前业务模块的中间某一个页面。那段日子对我们来说是灾难，因此我们开始切换到 redux ，并且基于 redux 开发了 dura 意在让 redux 更加的易于使用。

刚开始，我们十分的认同 redux 的 store 单根性的理论。可是随着微前端的到来，我们发现如果依然坚持 **单根性** ，那么将会很大程度的牺牲了我们基于 typescript 而做的类型系统，而在实际业务场景下，通常只有一个业务领域内的状态才会有精密的调度关联，所以我们提出了多 Store，我们认为在一个应用内 Store 不应该是完全的单根性，通常应该是在某一个业务领域内它具备**单根性** ， 而如何合理的划分**业务领域**，这将会是一门学问。这里推荐去适当的借鉴了解 **【DDD 领域驱动设计】**

# 为什么状态机内需要 watch？

在大多数的时候，react 组件内部我们可以通过 useEffect 来实现 watch 的一些功能，那么我们为什么依赖决定在状态机内部实现一套？因为在很多时候，我想做的仅仅只是监听某个状态发生变更之后做一件事，而这件事可能跟任何组件都是无关联的。如果把这样的逻辑放进状态机，那么势必会大大的增加后续维护的心智成本。
