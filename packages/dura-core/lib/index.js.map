{"version":3,"file":"index.js","sources":["../src/operator.ts","../src/defineStoreSlice.ts","../src/duraStoreSlice.ts","../src/index.ts"],"sourcesContent":["import type { ReducersMapObject } from \"redux\";\nimport type {\n  JsonObject,\n  StoreSlice,\n  EffectsMapOfStore,\n  EffectsMapOfStoreSlice,\n  ReducersMapOfStoreSlice,\n  StoreSliceMap,\n} from \"@dura/types\";\nimport invariant from \"invariant\";\nimport { produceWithPatches } from \"immer\";\nimport { defineHiddenConstantProperty, DURA_PATCHES_SYMBOL } from \"@dura/utils\";\n\nexport function operatorFactory() {\n  const globalReducers: ReducersMapObject = {};\n  const globalEffects: EffectsMapOfStore = {};\n  const globalStoreSlice: StoreSliceMap<any, any, any, any> = {};\n\n  function has<\n    N extends string,\n    S extends JsonObject,\n    R extends ReducersMapOfStoreSlice<S>,\n    E extends EffectsMapOfStoreSlice,\n    STORES extends StoreSlice<N, S, R, E>\n  >(store: STORES) {\n    return store.namespace in globalStoreSlice;\n  }\n\n  function getReducers() {\n    return globalReducers;\n  }\n\n  function getEffects() {\n    return globalEffects;\n  }\n\n  function use<\n    N extends string,\n    S extends JsonObject,\n    R extends ReducersMapOfStoreSlice<S>,\n    E extends EffectsMapOfStoreSlice,\n    STORES extends StoreSlice<N, S, R, E>[]\n  >(...storeArray: STORES) {\n    let index = -1;\n    while (++index < storeArray.length) {\n      const store = storeArray[index];\n\n      invariant(\n        !has(store),\n        \"store already exists, please note that the namespace needs to be unique!\"\n      );\n      globalReducers[store.namespace] = function (state = store.state, action) {\n        const [, reducerName] = action.type.split(\"/\");\n\n        const [nextState, patches] = produceWithPatches(function (draftState) {\n          store.reducers[reducerName]?.(draftState, action);\n        })(state);\n\n        const patchesOfStringify = patches.map(\n          (n) => `${store.namespace}.${n.path.join(\".\")}`\n        );\n        defineHiddenConstantProperty(\n          nextState,\n          DURA_PATCHES_SYMBOL,\n          patchesOfStringify\n        );\n        return nextState;\n      };\n      globalEffects[store.namespace] = store.effects;\n      globalStoreSlice[store.namespace] = store;\n    }\n  }\n\n  function unUse<\n    N extends string,\n    S extends JsonObject,\n    R extends ReducersMapOfStoreSlice<S>,\n    E extends EffectsMapOfStoreSlice,\n    STORES extends StoreSlice<N, S, R, E>[]\n  >(...storeArray: STORES) {\n    let index = -1;\n    while (++index < storeArray.length) {\n      const store = storeArray[index];\n      delete globalReducers[store.namespace];\n      delete globalEffects[store.namespace];\n      delete globalStoreSlice[store.namespace];\n    }\n  }\n\n  return {\n    use,\n    unUse,\n    getReducers,\n    getEffects,\n    has,\n  };\n}\n","import type {\n  JsonObject,\n  ReducersMapOfStoreSlice,\n  EffectsMapOfStoreSlice,\n} from \"@dura/types\";\n\nexport type WrapStoreSlice<N, S, R, E> = {\n  namespace: N;\n  state: S;\n  reducers: {\n    [K in keyof R]: R[K] extends (...args: infer PP) => infer RR\n      ? (state: S, action: any) => void\n      : R[K];\n  };\n  effects: E;\n};\n\nexport function defineStoreSlice<\n  N extends string,\n  S extends JsonObject,\n  R extends ReducersMapOfStoreSlice<S>,\n  E extends EffectsMapOfStoreSlice\n>(store: WrapStoreSlice<N, S, R, E>): WrapStoreSlice<N, S, R, E> {\n  return store;\n}\n","import { defineStoreSlice } from \"./defineStoreSlice\";\n\nexport default defineStoreSlice({\n  namespace: \"@@DURA\",\n  state: {\n    REFRESH: 0,\n  },\n  reducers: {\n    UPDATE(state, { payload: { REFRESH } }) {\n      state.REFRESH = REFRESH + Math.random();\n      return state;\n    },\n  },\n  effects: {},\n});\n","import type { PreloadedState, Store as ReduxStore } from \"redux\";\nimport type {\n  ConfiguraOptions,\n  JsonObject,\n  StoreSlice,\n  UnionToIntersection,\n  ExtractStateByStoreUnion,\n  ExtractAction,\n  ReducersMapOfStoreSlice,\n  EffectsMapOfStoreSlice,\n  CreateStoreReturn,\n} from \"@dura/types\";\nimport {\n  compose as reduxCompose,\n  applyMiddleware,\n  combineReducers,\n  createStore,\n} from \"redux\";\nimport { operatorFactory } from \"./operator\";\nimport {\n  defineHiddenConstantProperty,\n  DURA_STORE_EFFECTS,\n  DURA_STORE_REDUCERS,\n  createActionsFactory,\n} from \"@dura/utils\";\nimport { enablePatches, setAutoFreeze } from \"immer\";\nimport duraStoreSlice from \"./duraStoreSlice\";\nimport { createAsyncMiddleware } from \"@dura/async\";\n\nenablePatches();\nsetAutoFreeze(false);\n\nexport const defaultConfiguraOptions: ConfiguraOptions = {\n  middlewares: [],\n  enhancers: [],\n  preloadedState: undefined,\n  compose: reduxCompose,\n};\n\nexport * from \"./defineStoreSlice\";\n\nexport function configura(options?: ConfiguraOptions) {\n  return function create<\n    N extends string,\n    S extends JsonObject,\n    R extends ReducersMapOfStoreSlice<S>,\n    E extends EffectsMapOfStoreSlice,\n    STORES extends StoreSlice<N, S, R, E>[] = StoreSlice<N, S, R, E>[],\n    GA = UnionToIntersection<ExtractAction<STORES[number]>>,\n    GS = UnionToIntersection<ExtractStateByStoreUnion<STORES[number]>>\n  >(...stores: STORES): CreateStoreReturn<GS, GA> {\n    const {\n      middlewares = [],\n      enhancers = [],\n      compose = reduxCompose,\n      preloadedState,\n    } = options ?? defaultConfiguraOptions;\n\n    const operator = operatorFactory();\n\n    operator.use(...stores, duraStoreSlice);\n\n    const reduxStore = createStore(\n      combineReducers(operator.getReducers()),\n      preloadedState,\n      compose(\n        applyMiddleware(\n          ...middlewares,\n          createAsyncMiddleware(\n            (namespace, effectName) =>\n              operator.getEffects()[namespace]?.[effectName]\n          )\n        ),\n        ...enhancers\n      )\n    );\n\n    const actions = createActionsFactory(reduxStore)(...stores);\n\n    function createDuraStore() {\n      const duraStore = {\n        use,\n        unUse,\n        refresh,\n        actions,\n        ...reduxStore,\n      };\n      defineHiddenConstantProperty(\n        duraStore,\n        DURA_STORE_REDUCERS,\n        operator.getReducers()\n      );\n      defineHiddenConstantProperty(\n        duraStore,\n        DURA_STORE_EFFECTS,\n        operator.getEffects()\n      );\n      return duraStore;\n    }\n\n    function refresh(prefix: string) {\n      reduxStore.dispatch({\n        type: \"@@DURA/UPDATE\",\n        payload: { REFRESH: prefix },\n      });\n      return createDuraStore();\n    }\n\n    function use(...args) {\n      operator.use(...args);\n      reduxStore.replaceReducer(combineReducers(operator.getReducers()));\n      return createDuraStore();\n    }\n\n    function unUse(...args) {\n      operator.unUse(...args);\n      reduxStore.replaceReducer(combineReducers(operator.getReducers()));\n      return createDuraStore();\n    }\n\n    return createDuraStore() as any;\n  };\n}\n"],"names":["operatorFactory","globalReducers","globalEffects","globalStoreSlice","has","store","namespace","use","_i","storeArray","index","invariant","state","action","reducerName","type","split","_b","produceWithPatches","draftState","reducers","nextState","patchesOfStringify","map","n","path","join","defineHiddenConstantProperty","DURA_PATCHES_SYMBOL","effects","length","unUse","getReducers","getEffects","defineStoreSlice","REFRESH","UPDATE","_a","Math","random","enablePatches","setAutoFreeze","defaultConfiguraOptions","middlewares","enhancers","preloadedState","undefined","compose","reduxCompose","options","stores","_c","_d","operator","duraStoreSlice","reduxStore","createStore","combineReducers","applyMiddleware","createAsyncMiddleware","effectName","actions","createActionsFactory","createDuraStore","duraStore","refresh","DURA_STORE_REDUCERS","DURA_STORE_EFFECTS","prefix","dispatch","payload","args","replaceReducer"],"mappings":";;;;;;;;;;;;;;gRAagBA,IACd,IAAMC,EAAoC,GACpCC,EAAmC,GACnCC,EAAsD,GAE5D,SAASC,EAMPC,GACA,OAAOA,EAAMC,aAAaH,EAgE5B,MAAO,CACLI,IAtDF,eAME,aAAAC,mBAAAA,IAAAC,kBAEA,IADA,IAAIC,GAAS,eAEX,IAAML,EAAQI,EAAWC,GAEzBC,WACGP,EAAIC,GACL,4EAEFJ,EAAeI,EAAMC,WAAa,SAAUM,EAAqBC,gBAArBD,EAAQP,EAAMO,OAClD,IAAGE,EAAeD,EAAOE,KAAKC,MAAM,QAEpCC,EAAuBC,sBAAmB,SAAUC,wBACxDd,EAAMe,UAASN,0BAAeK,EAAYN,KADfK,CAE1BN,GAFIS,OAIDC,OAA6BC,KACjC,SAACC,GAAM,OAAGnB,EAAMC,cAAakB,EAAEC,KAAKC,KAAK,QAO3C,OALAC,+BACEN,EACAO,sBACAN,GAEKD,GAETnB,EAAcG,EAAMC,WAAaD,EAAMwB,QACvC1B,EAAiBE,EAAMC,WAAaD,KAzB7BK,EAAQD,EAAWqB,aA+C5BC,MAlBF,eAME,aAAAvB,mBAAAA,IAAAC,kBAEA,IADA,IAAIC,GAAS,IACJA,EAAQD,EAAWqB,QAAQ,CAClC,IAAMzB,EAAQI,EAAWC,UAClBT,EAAeI,EAAMC,kBACrBJ,EAAcG,EAAMC,kBACpBH,EAAiBE,EAAMC,aAOhC0B,YAhEF,WACE,OAAO/B,GAgEPgC,WA7DF,WACE,OAAO/B,GA6DPE,gBC7EY8B,EAKd7B,GACA,OAAOA,ECrBT,MAAgC,CAC9BC,UAAW,SACXM,MAAO,CACLuB,QAAS,GAEXf,SAAU,CACRgB,gBAAOxB,EAAOyB,OAAaF,oBAEzB,OADAvB,EAAMuB,QAAUA,EAAUG,KAAKC,SACxB3B,IAGXiB,QAAS,ICgBXW,kBACAC,iBAAc,OAEDC,EAA4C,CACvDC,YAAa,GACbC,UAAW,GACXC,oBAAgBC,EAChBC,QAASC,sCAKeC,GACxB,OAAO,eAQL,aAAAzC,mBAAAA,IAAA0C,kBACM,IAAAb,EAKFY,MAAAA,EAAAA,EAAWP,EAJbzB,gBAAA0B,aAAc,KACdQ,cAAAP,aAAY,KACZQ,YAAAL,aAAUC,YACVH,mBAGIQ,EAAWrD,IAEjBqD,EAAS9C,UAAT8C,IAAgBH,GAAQI,KAExB,IAAMC,EAAaC,cACjBC,kBAAgBJ,EAASrB,eACzBa,EACAE,kBACEW,iCACKf,GACHgB,yBACE,SAACrD,EAAWsD,0BACVP,EAASpB,aAAa3B,yBAAasD,UAGtChB,KAIDiB,EAAUC,uBAAqBP,gBAAeL,GAEpD,SAASa,IACP,IAAMC,KACJzD,MACAwB,QACAkC,UACAJ,WACGN,GAYL,OAVA5B,+BACEqC,EACAE,sBACAb,EAASrB,eAEXL,+BACEqC,EACAG,qBACAd,EAASpB,cAEJ+B,EAGT,SAASC,EAAQG,GAKf,OAJAb,EAAWc,SAAS,CAClBtD,KAAM,gBACNuD,QAAS,CAAEnC,QAASiC,KAEfL,IAGT,SAASxD,QAAI,aAAAC,mBAAAA,IAAA+D,kBAGX,OAFAlB,EAAS9C,UAAT8C,EAAgBkB,GAChBhB,EAAWiB,eAAef,kBAAgBJ,EAASrB,gBAC5C+B,IAGT,SAAShC,QAAM,aAAAvB,mBAAAA,IAAA+D,kBAGb,OAFAlB,EAAStB,YAATsB,EAAkBkB,GAClBhB,EAAWiB,eAAef,kBAAgBJ,EAASrB,gBAC5C+B,IAGT,OAAOA"}