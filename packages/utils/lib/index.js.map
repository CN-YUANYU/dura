{"version":3,"file":"index.js","sources":["../src/defineHiddenConstantProperty.ts","../src/Symbol.ts","../src/noop.ts","../src/merge.ts","../src/keys.ts","../src/createActions.ts","../src/createProxy.ts"],"sourcesContent":["export function defineHiddenConstantProperty<T, S extends symbol | string, V>(\n  target: T,\n  name: S,\n  value: V\n) {\n  Object.defineProperty(target, name, {\n    value: value,\n    enumerable: true,\n    writable: false,\n    configurable: true,\n  });\n}\n","export const DURA_SYMBOL = Symbol(\"@@DURA_SYMBOL\");\n\nexport const DURA_PATCHES_SYMBOL = Symbol(\"@@DURA_PATCHES_SYMBOL\");\n\nexport const DURA_STORE_REDUCERS = Symbol(\"@@DURA_STORE_REDUCERS\");\n\nexport const DURA_STORE_EFFECTS = Symbol(\"@@DURA_STORE_EFFECTS\");\n","export function noop() {\n  return {};\n}\n","import type { JsonObject } from \"@dura/types\";\nexport function merge(prev: JsonObject = {}, next: JsonObject = {}) {\n  return { ...prev, ...next };\n}\n","import type { JsonObject } from \"@dura/types\";\n\nexport function keys(target: JsonObject) {\n  return Object.keys(target);\n}\n","import type { Store as ReduxStore } from \"redux\";\nimport type {\n  StoreSlice,\n  JsonObject,\n  ReducersMapOfStoreSlice,\n  EffectsMapOfStoreSlice,\n  ExtractAction,\n  UnionToIntersection,\n} from \"@dura/types\";\nimport { noop } from \"./noop\";\nimport { merge } from \"./merge\";\nimport { keys } from \"./keys\";\n\nexport function createDispatch<S>(\n  reduxStore: ReduxStore<S>,\n  namespace: string,\n  methodName: string\n) {\n  return function (payload: any) {\n    return reduxStore.dispatch({\n      type: `${namespace}/${methodName}`,\n      payload,\n    });\n  };\n}\n\nexport function createActionsFactory<S>(reduxStore: ReduxStore<S>) {\n  return function <\n    N extends string,\n    S extends JsonObject,\n    R extends ReducersMapOfStoreSlice<S> = {},\n    E extends EffectsMapOfStoreSlice = {},\n    STORES extends StoreSlice<N, S, R, E>[] = StoreSlice<N, S, R, E>[],\n    RETURN = UnionToIntersection<ExtractAction<STORES[number]>>\n  >(...stores: STORES): RETURN {\n    return stores\n      .map((store) => ({\n        [store.namespace]: keys(merge(store.reducers, store.effects))\n          .map((methodName) => ({\n            [methodName]: createDispatch(\n              reduxStore,\n              store.namespace,\n              methodName\n            ),\n          }))\n          .reduce(merge, noop()),\n      }))\n      .reduce(merge, noop()) as any;\n  };\n}\n","import isPlainObject from \"lodash.isplainobject\";\nimport { DURA_SYMBOL, DURA_PATCHES_SYMBOL } from \"./Symbol\";\nimport { defineHiddenConstantProperty } from \"./defineHiddenConstantProperty\";\n\nexport function createProxy<T extends object>(\n  state: T,\n  deps: Map<string, number>,\n  parentPath?: string\n) {\n  const proxy = new Proxy(state, {\n    get(target, property, receiver) {\n      const value = Reflect.get(target, property, receiver);\n\n      //如果不是我自身定义的属性\n      if (!target.hasOwnProperty(property)) {\n        return value;\n      }\n      // 如果是 symbol 类型 则直接返回\n      if (property === DURA_SYMBOL || property === DURA_PATCHES_SYMBOL) {\n        return value;\n      }\n\n      const path = caclPath(parentPath, property);\n\n      if (isPlainObject(value) || Array.isArray(value)) {\n        defineHiddenConstantProperty(value, DURA_SYMBOL, 1);\n        return createProxy(value, deps, path);\n      }\n\n      const count = deps.get(path) + 1;\n      if (isNaN(count)) {\n        deps.set(path, 1);\n      } else {\n        deps.set(path, count);\n      }\n\n      return value;\n    },\n  });\n  return proxy;\n}\n\nfunction caclPath(parentPath, property) {\n  return parentPath ? `${parentPath}.${property}` : `${property}`;\n}\n"],"names":["defineHiddenConstantProperty","target","name","value","Object","defineProperty","enumerable","writable","configurable","DURA_SYMBOL","Symbol","DURA_PATCHES_SYMBOL","DURA_STORE_REDUCERS","DURA_STORE_EFFECTS","noop","merge","prev","next","keys","createDispatch","reduxStore","namespace","methodName","payload","dispatch","type","_i","stores","map","store","reducers","effects","reduce","createProxy","state","deps","parentPath","Proxy","get","property","receiver","Reflect","hasOwnProperty","path","caclPath","isPlainObject","Array","isArray","count","isNaN","set"],"mappings":"8LAAgBA,EACdC,EACAC,EACAC,GAEAC,OAAOC,eAAeJ,EAAQC,EAAM,CAClCC,MAAOA,EACPG,YAAY,EACZC,UAAU,EACVC,cAAc,QCTLC,EAAcC,OAAO,iBAErBC,EAAsBD,OAAO,yBAE7BE,EAAsBF,OAAO,yBAE7BG,EAAqBH,OAAO,iCCNzBI,IACd,MAAO;;;;;;;;;;;;;;4SCAOC,EAAMC,EAAuBC,GAC3C,oBADoBD,mBAAuBC,aAC/BD,GAASC,YCAPC,EAAKjB,GACnB,OAAOG,OAAOc,KAAKjB,YCULkB,EACdC,EACAC,EACAC,GAEA,OAAO,SAAUC,GACf,OAAOH,EAAWI,SAAS,CACzBC,KAASJ,MAAaC,EACtBC,kKAKkCH,GACtC,OAAO,eAOL,aAAAM,mBAAAA,IAAAC,kBACA,OAAOA,EACJC,KAAI,SAACC,SAAU,aACbA,EAAMR,WAAYH,EAAKH,EAAMc,EAAMC,SAAUD,EAAME,UACjDH,KAAI,SAACN,SAAe,aAClBA,GAAaH,EACZC,EACAS,EAAMR,UACNC,QAGHU,OAAOjB,EH5CT,SG8CFiB,OAAOjB,EH9CL,4DIGOkB,EACdC,EACAC,EACAC,GAgCA,OA9Bc,IAAIC,MAAMH,EAAO,CAC7BI,aAAIrC,EAAQsC,EAAUC,GACpB,IAAMrC,EAAQsC,QAAQH,IAAIrC,EAAQsC,EAAUC,GAG5C,IAAKvC,EAAOyC,eAAeH,GACzB,OAAOpC,EAGT,GAAIoC,IAAa9B,GAAe8B,IAAa5B,EAC3C,OAAOR,EAGT,IAAMwC,EAoBZ,SAAkBP,EAAYG,GAC5B,OAAOH,EAAgBA,MAAcG,EAAa,GAAGA,EArBpCK,CAASR,EAAYG,GAElC,GAAIM,UAAc1C,IAAU2C,MAAMC,QAAQ5C,GAExC,OADAH,EAA6BG,EAAOM,EAAa,GAC1CwB,EAAY9B,EAAOgC,EAAMQ,GAGlC,IAAMK,EAAQb,EAAKG,IAAIK,GAAQ,EAO/B,OANIM,MAAMD,GACRb,EAAKe,IAAIP,EAAM,GAEfR,EAAKe,IAAIP,EAAMK,GAGV7C"}